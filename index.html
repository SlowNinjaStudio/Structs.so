<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <title></title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="">
  <meta property="og:type" content="">
  <meta property="og:url" content="">
  <meta property="og:image" content="">

  <link rel="manifest" href="site.webmanifest">
  <link rel="apple-touch-icon" href="icon.png">
  <!-- Place favicon.ico in the root directory -->

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/normalize.css">
  <link href="https://unpkg.com/nes.css@2.2.0/css/nes.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="css/main.css">

  <meta name="theme-color" content="#fafafa">
  <style>
    body {
      background: url(/img/background/space-texture.png);
      background-size: 256px 256px;
      image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-crisp-edges;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    h1 {
      font-size: 32px;
      font-weight: normal;
      text-align: center;
    }

    .container {
      margin-top: 64px;
    }
    .structure-card {
      background: #FFFFFF;
      display: inline-block;
      width: 392px;
      max-width: 100%;
      margin: 20px;
      vertical-align: top;
    }
    .pixel-art-placeholder {
      display: inline-block;
      width:256px;
      height:256px;
      max-width:100%;
      background:#CCC;
      border:1px solid black;
      margin-bottom: 40px;
    }
    .details {
      font-family: sans-serif;
      font-size: 14px;
    }
    .attribute-label {
      font-weight: bold;
    }
    .nes-container.with-title>.title {
      font-weight: normal;
    }
    .nes-container.structure-card > .nes-container.with-title {
      margin-bottom: 20px;
    }
    .nes-container.structure-card > .game-asset-wrapper {
      margin: 0 auto 20px auto;
    }
    .nav {
      background: #222222;
      position: fixed;
      top: 0;
      left: 0;
      border-top: none;
      border-bottom: 4px solid #000000;
      height: 64px;
      width: 100%;
      z-index: 10;
      padding: 20px;
      color: #fff;
    }
  </style>
</head>

<body>
<div class="nav">Structures</div>
<div class="container">

  <div id="color-container" style="background: white"></div>

  <div class="nes-container structure-card" style="display: none">
    <div class="pixel-art-placeholder"></div>
    <div class="nes-container with-title">
      <h3 class="title">Mobile Structure</h3>
      <div class="details">
        <div>Mobile offensive crab units</div>
        <br>
        <div><span class="attribute-label">Structure ID:</span> 5</div>
        <div><span class="attribute-label">Health:</span> 79/79</div>
        <div><span class="attribute-label">Battery Charge:</span> 1405303 watt</div>
      </div>
    </div>
    <div class="nes-container with-title">
      <h3 class="title">Power Systems</h3>
      <div class="details">
        <div><span class="attribute-label">Generation Rate:</span> 31</div>
        <div><span class="attribute-label">Charge Rate:</span> 507</div>
        <div><span class="attribute-label">Drain Rate:</span> 351</div>
      </div>
    </div>
    <div class="nes-container with-title">
      <h3 class="title">Engineering Systems</h3>
      <div class="details">
        <div><span class="attribute-label">Build Rate:</span> 31</div>
        <div><span class="attribute-label">Restoration Rate:</span> 16</div>
      </div>
    </div>
  </div>
  <div id="structures-list"></div>
</div>

  <script>
    const AMBITS = {
      LAND: 'LAND',
      SKY: 'SKY',
      SPACE: 'SPACE',
      WATER: 'WATER',
    };
    const FEATURES = {
      ATTACK: 'ATTACK_SYSTEM',
      DEFENSIVE: 'DEFENSIVE_SYSTEM',
      ENGINEERING: 'ENGINEERING_SYSTEM',
      POWER: 'POWER_SYSTEM',
      STORAGE: 'STORAGE_SYSTEM'
    }

    /**
     * Encapsulate and abstract HTTP request methods.
     */
    class JsonAjaxer {
      async get (url) {
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          },
          redirect: 'follow'
        });
        return response.json();
      }
    }

    class Structure {
      constructor() {
        this.accuracy = 0;
        this.ambits = [];
        this.battery = {
          amount: 0,
          denom: ''
        };
        this.build_rate = 0;
        this.capacity_current = 0;
        this.capacity_max = 0;
        this.charge_rate = 0;
        this.charging_slot = [];
        this.charging_slots = 0;
        this.creator = '';
        this.description = '';
        this.drain_rate = 0;
        this.energy_efficiency = 0;
        this.energy_to_build = {
          amount: 0,
          denom: ''
        }
        this.generate_rate = 0;
        this.features = [];
        this.hash ='';
        this.health_current = 0;
        this.health_max = 0;
        this.id = '';
        this.input = '';
        this.is_mobile = false;
        this.mass = 0;
        this.melee_attack = 0;
        this.melee_defense = 0;
        this.name = '';
        this.owner = '';
        this.parent_id = '';
        this.primary_color = '';
        this.range_attack = 0;
        this.range_defense = 0;
        this.restoration_rate = 0;
        this.schematic = '';
        this.speed = 0;
        this.storage = [];
        this.strength = 0;
        this.supervisor = '';
      }

      /* Base Attributes */
      getId() {
        return this.id;
      }
      getName() {
        return this.name;
      }
      getDescription() {
        return this.description;
      }
      getHealthCurrent() {
        return this.health_current;
      }
      getHealthMax() {
        return this.health_max;
      }
      getBatteryAmount() {
        return this.battery.amount;
      }
      getBatteryDenom() {
        return this.battery.denom;
      }
      getAmbits() {
         return this.ambits.join(', ');
      }
      getSpeed() {
        return this.speed;
      }
      getAccuracy() {
        return this.accuracy;
      }
      getMass() {
        return this.mass;
      }
      getStrength() {
        return this.strength;
      }
      getEnergyEfficiency() {
        return this.energy_efficiency;
      }
      getPrimaryColor() {
        return this.primary_color;
      }

      isMobile() {
        return this.is_mobile;
      }

      hasAmbit(ambit) {
        return this.ambits.includes(ambit);
      }
      hasAmbitLand() {
        return this.hasAmbit(AMBITS.LAND);
      }
      hasAmbitSky() {
        return this.hasAmbit(AMBITS.SKY);
      }
      hasAmbitSpace() {
        return this.hasAmbit(AMBITS.SPACE);
      }
      hasAmbitWater() {
        return this.hasAmbit(AMBITS.WATER);
      }

      hasFeature(feature) {
        return this.features.includes(feature);
      }
      hasFeatureAttack() {
        return this.hasFeature(FEATURES.ATTACK);
      }
      hasFeatureDefensive() {
        return this.hasFeature(FEATURES.DEFENSIVE);
      }
      hasFeatureEngineering() {
        return this.hasFeature(FEATURES.ENGINEERING);
      }
      hasFeaturePower() {
        return this.hasFeature(FEATURES.POWER);
      }
      hasFeatureStorage() {
        return this.hasFeature(FEATURES.STORAGE);
      }

      /* Attack */
      getMeleeAttack() {
        return this.melee_attack;
      }
      getRangeAttack() {
        return this.range_attack;
      }

      /* Defensive */
      getMeleeDefense() {
        return this.melee_defense;
      }
      getRangeDefense() {
        return this.range_defense;
      }

      /* Engineering */
      getBuildRate() {
        return this.build_rate;
      }
      getRestorationRate() {
        return this.restoration_rate;
      }

      /* Power */
      getGenerationRate() {
        return this.generate_rate;
      }
      getChargeRate() {
        return this.charge_rate;
      }
      getDrainRate() {
        return this.drain_rate;
      }
    }

    class StructureFactory {
      make(obj) {
        const structure = new Structure();
        Object.assign(structure, obj);
        return structure;
      }
    }

    class DroidApi {
      constructor(scheme, domain, ajax) {
        this.scheme = scheme;
        this.domain = domain;
        this.ajax = (ajax !== undefined) ? ajax: new JsonAjaxer();
      }
      getStructures() {
        return this.ajax.get(`${this.scheme}${this.domain}/api/di/Structure`)
          .then(data => {
            const structureFactory = new StructureFactory();
            const structures = [];
            for (let i = 0; i < data.Structure.length; i ++) {
              structures[i] = structureFactory.make(data.Structure[i]);
            }
            return structures;
          })
      }
    }

    class StructureArtGenerator {
      constructor() {
        this.imgDir = 'img/structures/';
        this.backgroundsDir = 'backgrounds/';
        this.mobileDir = 'mobile/';
        this.staticDir = 'static/';
      }

      /* Backgrounds */
      backgroundDefault(layers) {
        layers.push(`${this.imgDir}${this.backgroundsDir}structure-bg-default.png`)
      }
      backgroundLand(layers, structure) {
        if (structure.hasAmbitLand()) {
          layers.push(`${this.imgDir}${this.backgroundsDir}structure-bg-land.png`);
        }
      }
      backgroundSky(layers, structure) {
        if (structure.hasAmbitSky()) {
          layers.push(`${this.imgDir}${this.backgroundsDir}structure-bg-sky.png`);
        }
      }
      backgroundSpace(layers, structure) {
        if (structure.hasAmbitSpace()) {
          layers.push(`${this.imgDir}${this.backgroundsDir}structure-bg-space.png`);
        }
      }
      backgroundWater(layers, structure) {
        if (structure.hasAmbitWater()) {
          layers.push(`${this.imgDir}${this.backgroundsDir}structure-bg-water.png`);
        }
      }
      backgroundLayerFilter(layers) {
        layers.push(`${this.imgDir}${this.backgroundsDir}structure-bg-lighten-15.png`);
      }

      /* Mobile Structure Base */
      mobileStructureChassis(layers) {
        layers.push(`${this.imgDir}${this.mobileDir}structure-mobile-chassis.png`);
      }

      /* Mobile Structure Ambit Parts */
      mobileStructureLand(layers, structure) {
        if (structure.hasAmbitLand()) {
          layers.push(`${this.imgDir}${this.mobileDir}structure-mobile-land.png`);
        }
      }
      mobileStructureSky(layers, structure) {
        if (structure.hasAmbitSky()) {
          layers.push(`${this.imgDir}${this.mobileDir}structure-mobile-sky.png`);
        }
      }
      mobileStructureSpace(layers, structure) {
        if (structure.hasAmbitSpace()) {
          layers.push(`${this.imgDir}${this.mobileDir}structure-mobile-space.png`);
        }
      }
      mobileStructureWater(layers, structure) {
        if (structure.hasAmbitWater()) {
          layers.push(`${this.imgDir}${this.mobileDir}structure-mobile-water.png`);
        }
      }

      /* Mobile Structure Feature Parts */
      mobileStructureAttack(layers, structure) {
        if (structure.hasFeatureAttack()) {
          layers.push(`${this.imgDir}${this.mobileDir}structure-mobile-attack.png`);
        }
      }
      mobileStructureDefensive(layers, structure) {
        if (structure.hasFeatureDefensive()) {
          layers.push(`${this.imgDir}${this.mobileDir}structure-mobile-attack.png`);
        }
      }
      mobileStructureEngineering(layers, structure) {
        if (structure.hasFeatureEngineering()) {
          layers.push(`${this.imgDir}${this.mobileDir}structure-mobile-engineering.png`);
        }
      }
      mobileStructurePower(layers, structure) {
        if (structure.hasFeaturePower()) {
          layers.push(`${this.imgDir}${this.mobileDir}structure-mobile-power.png`);
        }
      }

      mobileStructure(layers, structure) {
        this.mobileStructureChassis(layers);

        this.mobileStructureLand(layers, structure);
        this.mobileStructureSky(layers, structure);
        this.mobileStructureSpace(layers, structure);
        this.mobileStructureWater(layers, structure);

        this.mobileStructureAttack(layers, structure);
        this.mobileStructureDefensive(layers, structure);
        this.mobileStructureEngineering(layers, structure);
        this.mobileStructurePower(layers, structure);
      }

      /* Static Structure Base */
      staticStructureBuildings(layers) {
        layers.push(`${this.imgDir}${this.staticDir}structure-static-buildings.png`);
      }

      /* Static Structure Ambit Parts */
      staticStructureSky(layers, structure) {
        if (structure.hasAmbitSky()) {
          layers.push(`${this.imgDir}${this.staticDir}structure-static-buildings-base.png`);
          layers.push(`${this.imgDir}${this.staticDir}structure-static-sky.png`);
        }
      }
      staticStructureSpace(layers, structure) {
        if (structure.hasAmbitSpace()) {
          layers.push(`${this.imgDir}${this.staticDir}structure-static-buildings-base.png`);
          layers.push(`${this.imgDir}${this.staticDir}structure-static-space.png`);
        }
      }
      staticStructureWater(layers, structure) {
        if (structure.hasAmbitWater()) {
          layers.push(`${this.imgDir}${this.staticDir}structure-static-buildings-base.png`);
          layers.push(`${this.imgDir}${this.staticDir}structure-static-water.png`);
        }
      }

      /* Static Structure Feature Parts */
      staticStructureAttack(layers, structure) {
        if (structure.hasFeatureAttack()) {
          layers.push(`${this.imgDir}${this.staticDir}structure-static-attack.png`);
        }
      }
      staticStructureDefensive(layers, structure) {
        if (structure.hasFeatureDefensive()) {
          layers.push(`${this.imgDir}${this.staticDir}structure-static-attack.png`);
        }
      }
      staticStructureEngineering(layers, structure) {
        if (structure.hasFeatureEngineering()) {
          layers.push(`${this.imgDir}${this.staticDir}structure-static-engineering.png`);
        }
      }
      staticStructurePower(layers, structure) {
        if (structure.hasFeaturePower()) {
          layers.push(`${this.imgDir}${this.staticDir}structure-static-power.png`);
        }
      }

      staticStructure(layers, structure) {
        this.staticStructureBuildings(layers);

        this.staticStructureSky(layers, structure);
        this.staticStructureSpace(layers, structure);
        this.staticStructureWater(layers, structure);

        this.staticStructureAttack(layers, structure);
        this.staticStructureDefensive(layers, structure);
        this.staticStructureEngineering(layers, structure);
        this.staticStructurePower(layers, structure);
      }

      /**
       * Generate the art for a given structure.
       * @param {Structure} structure
       */
      generate(structure) {
        let layers = [];
        this.backgroundDefault(layers);
        this.backgroundSpace(layers, structure);
        this.backgroundSky(layers, structure);
        this.backgroundLand(layers, structure);
        this.backgroundWater(layers, structure);
        this.backgroundLayerFilter(layers);
        if (structure.isMobile()) {
          this.mobileStructure(layers, structure);
        } else {
          this.staticStructure(layers, structure);
        }
        return layers;
      }
    }

    class StructureMobilePalette {
      constructor() {
        this.chassisTop = new ColorRGB(255, 152, 0);
        this.chassisBottom = new ColorRGB(255, 87, 34);
        this.waterFin = new ColorRGB(225, 186, 0);
        this.landTire = new ColorRGB(88, 88, 88);
        this.landHubCap = new ColorRGB(192, 192, 192);
        this.skyWing = new ColorRGB(244, 67, 54);
        this.spaceFlameCore = new ColorRGB(254, 254, 254);
        this.spaceInnerFlame = new ColorRGB(255, 213, 79);
        this.spaceOuterFlame = new ColorRGB(255, 61, 0);
        this.attackGunBarrel = new ColorRGB(158, 158, 158);
        this.attackGunAccent = new ColorRGB(255, 179, 0);
        this.powerLightColor = new ColorRGB(118, 255, 3);
        this.engineeringCraneArm = new ColorRGB(132, 175, 196);
        this.engineeringCraneClaw = new ColorRGB(220, 232, 238);
      }

      generateChassisPaletteSwap(paletteSwap, primaryColor) {
        const shades = primaryColor.getShades(2);
        paletteSwap.push([this.chassisTop, shades[0]]);
        paletteSwap.push([this.chassisBottom, shades[1]]);
      }

      generatePaletteSwap(primaryColor) {
        const paletteSwap = [];
        this.generateChassisPaletteSwap(paletteSwap, primaryColor);
        return paletteSwap;
      }
    }

    class StructureStaticPalette {
      constructor() {
        this.buildingsLeft = new ColorRGB(224, 224, 224);
        this.buildingsCenterLeft = new ColorRGB(158, 158, 158);
        this.buildingsCenter = new ColorRGB(238, 238, 238);
        this.buildingsCenterStripe = new ColorRGB(85, 85, 85);
        this.buildingsCenterRight = new ColorRGB(224, 224, 224);
        this.buildingsRight = new ColorRGB(189, 189, 189);
        this.buildingsBaseTop = new ColorRGB(176, 190, 197);
        this.buildingsBaseBottom = new ColorRGB(96, 125, 139);
        this.skyInnerFlame = new ColorRGB(255, 235, 59);
        this.skyOuterFlame = new ColorRGB(213, 0, 0);
        this.defenseInnerShield = new ColorRGB(128, 216, 255);
        this.defenseOuterShield = new ColorRGB(224, 247, 250);
        this.powerLightColor = new ColorRGB(118, 255, 3);
        this.engineeringCraneTower = new ColorRGB(255, 193, 7);
        this.engineeringCraneClaw = new ColorRGB(147, 147, 135);
        this.attackTurret = new ColorRGB(124, 146, 90);
      }

      generateBuildingsPaletteSwap(paletteSwap, primaryColor) {
        const newMainColor = this.buildingsCenter.mixColors(primaryColor, 0.10);
        const shades = newMainColor.getShades(5);
        paletteSwap.push([this.buildingsCenter, shades[0]]);
        paletteSwap.push([this.buildingsLeft, shades[1]]);
        paletteSwap.push([this.buildingsRight, shades[2]]);
        paletteSwap.push([this.buildingsCenterLeft, shades[3]]);
        paletteSwap.push([this.buildingsCenterStripe, shades[4]]);
      }

      generatePaletteSwap(primaryColor) {
        const paletteSwap = [];
        this.generateBuildingsPaletteSwap(paletteSwap, primaryColor);
        return paletteSwap;
      }
    }

    class DroidUIStructure {
      constructor(structure, idPrefix = '') {
        this.structure = structure;
        this.idPrefix = idPrefix;
      }
      getCanvasId() {
        return `${this.idPrefix}structure-${this.structure.getId()}`;
      }
      render() {
        return `
          <div class="nes-container structure-card">
            <div class="game-asset-wrapper">
              <canvas id="${this.getCanvasId()}" class="pixel-art-viewer" width="64" height="64">
                Your browser does not support the canvas element.
              </canvas>
            </div>
            <div class="nes-container with-title">
              <h3 class="title">Attributes</h3>
              <div class="details">
                <h4>${this.structure.getName()}</h4>
                <p>${this.structure.getDescription()}</p>
                <br>
                <div><span class="attribute-label">Structure ID:</span> ${this.structure.getId()}</div>
                <div><span class="attribute-label">Health:</span> ${this.structure.getHealthCurrent()} / ${this.structure.getHealthMax()}</div>
                <div><span class="attribute-label">Battery Charge:</span> ${this.structure.getBatteryAmount()} ${this.structure.getBatteryDenom()}</div>
                <div><span class="attribute-label">Ambits:</span> ${this.structure.getAmbits()}</div>
                <br>
                <div><span class="attribute-label">Speed:</span> ${this.structure.getSpeed()}</div>
                <div><span class="attribute-label">Accuracy:</span> ${this.structure.getAccuracy()} / ${this.structure.getHealthMax()}</div>
                <div><span class="attribute-label">Mass:</span> ${this.structure.getMass()}</div>
                <div><span class="attribute-label">Strength:</span> ${this.structure.getStrength()}</div>
                <div><span class="attribute-label">Energy Efficiency:</span> ${this.structure.getEnergyEfficiency()}</div>
              </div>
            </div>
            ${(this.structure.hasFeatureAttack()) ? `
              <div class="nes-container with-title">
                <h3 class="title">Attack Systems</h3>
                <div class="details">
                  <div><span class="attribute-label">Melee Attack:</span> ${this.structure.getMeleeAttack()}</div>
                  <div><span class="attribute-label">Range Attack:</span> ${this.structure.getRangeAttack()}</div>
                </div>
              </div>
            ` : ''}
            ${(this.structure.hasFeatureDefensive()) ? `
              <div class="nes-container with-title">
                <h3 class="title">Defensive Systems</h3>
                <div class="details">
                  <div><span class="attribute-label">Melee Defense:</span> ${this.structure.getMeleeDefense()}</div>
                  <div><span class="attribute-label">Range Defense:</span> ${this.structure.getRangeDefense()}</div>
                </div>
              </div>
            ` : ''}
            ${(this.structure.hasFeatureEngineering()) ? `
              <div class="nes-container with-title">
                <h3 class="title">Engineering Systems</h3>
                <div class="details">
                  <div><span class="attribute-label">Build Rate:</span> ${this.structure.getBuildRate()}</div>
                  <div><span class="attribute-label">Restoration Rate:</span> ${this.structure.getRestorationRate()}</div>
                </div>
              </div>
            ` : ''}
            ${(this.structure.hasFeaturePower()) ?
              `<div class="nes-container with-title">
                <h3 class="title">Power Systems</h3>
                <div class="details">
                  <div><span class="attribute-label">Generation Rate:</span> ${this.structure.getGenerationRate()}</div>
                  <div><span class="attribute-label">Charge Rate:</span> ${this.structure.getChargeRate()}</div>
                  <div><span class="attribute-label">Drain Rate:</span> ${this.structure.getDrainRate()}</div>
                </div>
              </div>`
            : ''}
          </div>
        `;
      }
    }

    class DroidUI {

      /**
       * @param {DroidApi} droidApi
       * @param {StructureArtGenerator} structureArtGenerator
       * @param {StructureMobilePalette} structureMobilePalette
       * @param {StructureStaticPalette} structureStaticPalette
       */
      constructor(
        droidApi = new DroidApi('http://', 'droid.sh'),
        structureArtGenerator = new StructureArtGenerator(),
        structureMobilePalette = new StructureMobilePalette(),
        structureStaticPalette = new StructureStaticPalette()
      ) {
        this.droidApi = droidApi;
        this.structureArtGenerator = structureArtGenerator;
        this.structureMobilePalette = structureMobilePalette;
        this.structureStaticPalette = structureStaticPalette;
        this.structures = [];
      }

      /**
       * @param {Structure} structure
       */
      getPalette(structure) {
        let palette = [];
        const primaryColor = ColorRGB.hexToRgb(structure.getPrimaryColor());
        if (structure.isMobile() === true) {
          palette = this.structureMobilePalette.generatePaletteSwap(primaryColor);
        } else {
          palette = this.structureStaticPalette.generatePaletteSwap(primaryColor);
        }
        return palette;
      }

      /**
       * Load all structures and display them in the target element.
       *
       * @param {string} targetElementId
       */
      loadStructures(targetElementId) {
        const targetElement = document.getElementById(targetElementId);

        let structuresHtml = '';

        this.droidApi.getStructures().then(structures => {
          for (let i = 0; i < structures.length; i++) {
            const droidUIStructure = new DroidUIStructure(structures[i]);

            // Batch drawing by collecting all the HTML first
            structuresHtml += droidUIStructure.render();

            this.structures[i] = {
              'structure': structures[i],
              'droidUIStructure': droidUIStructure,
              'layers': this.structureArtGenerator.generate(structures[i]),
            }
          }

          // Update DOM
          targetElement.innerHTML = structuresHtml;

          for (let i = 0; i < this.structures.length; i++) {
            /** @type {HTMLCanvasElement} */
            const canvas = document.getElementById(this.structures[i].droidUIStructure.getCanvasId());
            new PixelArtViewer(canvas, this.structures[i].layers, this.getPalette(this.structures[i].structure));
          }
        });
      }
    }

    class ColorRGB {
      constructor(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
      }

      /**
       * Return the RGB complimentary color for the given RGB color.
       */
      getComplimentaryColor() {
        return new ColorRGB(
          255 - this.r,
          255 - this.g,
          255 - this.b
        );
      }

      /**
       * Generate a grey based on the luminosity of the given color.
       */
      getGrey() {
        const avg = Math.round((this.r + this.g + this.b) / 3);
        return new ColorRGB(
          avg,
          avg,
          avg
        );
      }

      /**
       * @param {ColorRGB} otherColor
       * @param {number} ratio a number between 0 - 1, 0 being the current color and 1 being the other color.
       */
      mixColors(otherColor, ratio = 0.5) {
        return new ColorRGB(
          Math.round(this.r * ratio + otherColor.r * (1 - ratio)),
          Math.round(this.g * ratio + otherColor.g * (1 - ratio)),
          Math.round(this.b * ratio + otherColor.b * (1 - ratio))
        );
      }

      /**
       * @param {number} numShades the number of shades to generate
       * @param {boolean} lightToDark whether or not the shades are ordered light to dark or from dark to light
       * @return {Array.<ColorRGB>}
       */
      getShades(numShades, lightToDark = true) {
        const shades = [];

        for (let i = 0; i < numShades; i++) {
          const numerator = lightToDark ? numShades - i : i + 1;
          shades.push(new ColorRGB(
            Math.round(this.r * (numerator / numShades)),
            Math.round(this.g * (numerator / numShades)),
            Math.round(this.b * (numerator / numShades))
          ));
        }
        return shades;
      }

      /**
       * @param {string} hex color code
       * @returns {ColorRGB}
       */
      static hexToRgb(hex) {
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);

        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return new ColorRGB(
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16)
        );
      }
    }

    class PixelArtViewer {

      /**
       * @param {HTMLCanvasElement} canvas the target canvas that will become the viewer
       * @param {Array.<string>} imageLayerPaths the paths to the images to render. Image layers are rendered in order.
       * @param {Array.<Array>} palette list of colors to swap
       */
      constructor(canvas, imageLayerPaths, palette = []) {
        this.canvas = canvas;
        this.aspectRatio = canvas.height / canvas.width;
        this.context = canvas.getContext("2d");
        this.imageLayerPaths = imageLayerPaths;
        this.numImagesLoaded = 0;
        this.layers = [];
        this.palette = palette;

        this.lockAspectRatio();
        this.loadAndRenderImageLayers();
      }

      /**
       * Locks the aspect ratio so that the aspect ratio is maintained even if the image is responsively resized.
       */
      lockAspectRatio() {
        this.canvas.height = this.canvas.width * this.aspectRatio;
      }

      /**
       * Check that all images have been loaded. Used before rendering to reduce re-renders.
       * @returns {boolean}
       */
      areAllImagesLoaded() {
        return this.numImagesLoaded === this.imageLayerPaths.length;
      }

      /**
       * Loads and renders the image layers in the order defined by the image paths.
       */
      loadAndRenderImageLayers() {
        for(let i = 0; i < this.imageLayerPaths.length; i++) {
          const img = new Image();
          const viewer = this;
          img.onload = () => {
            viewer.numImagesLoaded++;
            if (viewer.areAllImagesLoaded()) {
              viewer.render();
            }
          }
          img.src = this.imageLayerPaths[i];
          this.layers[i] = img;
        }
      }

      /**
       * Draw all image layers to the canvas in order.
       */
      render() {
        this.clearCanvas();
        for(let i = 0; i < this.layers.length; i++) {
          this.context.drawImage(this.layers[i], 0, 0);
        }
        this.swapColors(this.palette);
      }

      /**
       * Swap colors in the canvas.
       * @param {ColorRGB} targetColor
       * @param {ColorRGB} newColor
       */
      swapColor(targetColor, newColor) {
        const imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const red = data[i];
          const green = data[i + 1];
          const blue = data[i + 2];
          if (red === targetColor.r && green === targetColor.g && blue === targetColor.b) {
            data[i]     = newColor.r; // red
            data[i + 1] = newColor.g; // green
            data[i + 2] = newColor.b; // blue
          }
        }
        this.context.putImageData(imageData, 0, 0);
      }

      /**
       * Given an array of color pairs, swap the first color with the second color in the canvas.
       * @param {Array.<Array>} colorSwapList
       */
      swapColors(colorSwapList) {
        for (let i = 0; i < colorSwapList.length; i++) {
          this.swapColor(colorSwapList[i][0], colorSwapList[i][1]);
        }
      }

      clearCanvas() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    }

    const droidUi = new DroidUI();
    droidUi.loadStructures('structures-list');

    /**
     * @param {ColorRGB} color
     */
    function colorBlock(color) {
      return `<div style="width:40px; height:40px; display:inline-block; background: rgb(${color.r}, ${color.g}, ${color.b})"></div>`;
    }

    const primaryColor = new ColorRGB(255, 145, 0);
    const complimentaryColor = primaryColor.getComplimentaryColor();
    const primaryGreyColor = primaryColor.getGrey();
    let shades = primaryColor.getShades(7, false);
    shades = shades.concat(complimentaryColor.getShades(7, true));
    shades = shades.concat(primaryGreyColor.getShades(7, false));
    const mixedColor = primaryColor.mixColors(new ColorRGB(238, 238, 238), 0.10);
    shades = shades.concat(mixedColor.getShades(7, true));
    var colorBlocks = '';
    for (let i = 0; i < shades.length; i++) {
      colorBlocks += colorBlock(shades[i]);
    }
    document.getElementById('color-container').innerHTML = colorBlocks;

  </script>

  <script src="js/vendor/modernizr-3.11.2.min.js"></script>
  <script src="js/plugins.js"></script>
  <script src="js/main.js"></script>

  <!-- Google Analytics: change UA-XXXXX-Y to be your site's ID. -->
<!--  <script>-->
<!--    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;-->
<!--    ga('create', 'UA-XXXXX-Y', 'auto'); ga('set', 'anonymizeIp', true); ga('set', 'transport', 'beacon'); ga('send', 'pageview')-->
<!--  </script>-->
<!--  <script src="https://www.google-analytics.com/analytics.js" async></script>-->
</body>

</html>
