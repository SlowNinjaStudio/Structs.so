<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title></title>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<style>
		html, body {
			image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-crisp-edges;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
		}
		canvas {
			width:  256px;
		}
		</style>
	</head>
	<body>
		<canvas id="my-canvas" width="64" height="64"></canvas>
		<script>
			class Uint8ClampedArrayUtil {
				static concat(array1, array2) {
					const concatenated = new Uint8ClampedArray(array1.length + array2.length);
					concatenated.set(array1);
					concatenated.set(array2, array1.length);
					return concatenated;
				}

				static reversePixels(arr) {
					const reversed = [];
					for (let i = arr.length; i > 0; i -= 4) {
						reversed.push(arr[i - 4]);
						reversed.push(arr[i - 3]);
						reversed.push(arr[i - 2]);
						reversed.push(arr[i - 1]);
					}
					return new Uint8ClampedArray(reversed);
				}

				// a = new Uint8ClampedArray([111, 112, 113, 114, 121, 122, 123, 124, 211, 212, 213, 214, 221, 222, 223, 224])
				// Uint8ClampedArrayUtil.flipHorizontal(a, 2)
				// 121, 122, 123, 124, 111, 112, 113, 114, 221, 222, 223, 224, 211, 212, 213, 214
				static flipHorizontal(arr, width) {
					let arrayWidth = 4 * width;
					let flipped = new Uint8ClampedArray([]);
					for(let i = 0; i < arr.length; i += arrayWidth) {
						const sub = arr.subarray(i, i + arrayWidth);
						flipped = Uint8ClampedArrayUtil.concat(flipped, this.reversePixels(sub));
					}
					return flipped;
				}
			}


			/**
			 * An animation engine to assist with canvas animation.
			 */
			class AnimationEngine {

				/**
				 * @param {string} canvasId
         * @param {object} options
				 * @param {number} refreshRate the animation speed
				 */
				constructor(canvasId, options = {}, refreshRate = 20) {
					this.canvasId = canvasId;
					this.canvas = document.getElementById('my-canvas');
					this.context = this.canvas.getContext('2d');
          this.options = options;
					this.refreshRate = refreshRate;
					this.animatedObjects = [];
					this.interval = null;
				}

				clearCanvas() {
					this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
				}

				/**
				 * Register an animated object to be drawn on each refresh.
				 *
				 * @param {AnimatedImage|AnimatedEffect} object
				 */
				registerAnimatedObject(object) {
					object.setCanvas(this.canvas);
					object.setContext(this.context);
					this.animatedObjects.push(object);
				}

				/**
				 * Bulk register animated objects.
				 *
				 * @param {Array.<AnimatedImage|AnimatedEffect>} objects
				 */
				registerAnimatedObjects(objects) {
					for (let i = 0; i < objects.length; i++) {
						this.registerAnimatedObject(objects[i]);
					}
				}

        /**
         * Flip the animation horizontally.
         */
        flipHorizontally() {
          let imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
          const newData = Uint8ClampedArrayUtil.flipHorizontal(imageData.data, 64);
          for (let i = 0; i < imageData.data.length; i++) {
            imageData.data[i] = newData[i];
          }
          this.context.putImageData(imageData, 0, 0);
        }

				/**
				 * Draw all registered animated objects to the canvas.
				 */
				draw() {
					// Need to clear the canvas with every new frame, otherwise new objects will be drawn on top of old objects.
					this.clearCanvas();

					for (let i = 0; i < this.animatedObjects.length; i++) {
						this.animatedObjects[i].increaseFrameCount(); // Increase the frame count so that objects know how many frames have passed.
						this.animatedObjects[i].draw();
					}

          if (this.options.hasOwnProperty('flipHorizontally') && this.options.flipHorizontally) {
            this.flipHorizontally();
          }
				}

				/**
				 * Play the animation by running each animated objects' draw script.
				 */
				play() {
					this.interval = setInterval(this.draw.bind(this), this.refreshRate);
				}

				/**
				 * Pause the animation.
				 */
				pause() {
					clearInterval(this.interval);
				}

			}

			/**
			 * Used for animating a preexisting image.
			 */
			class AnimatedImage {

				/**
				 * @param {string} imagePath
				 * @param {function} draw the script that animates the image when called repeatedly
				 * @param {number} x starting horizontal position on the canvas
				 * @param {number} y starting vertical position on the canvas
				 */
				constructor(imagePath, draw, x, y) {
					this.imagePath = imagePath;
					this.draw = draw;
					this.x = x;
					this.y = y;
					this.canvas = null;
					this.context = null;
					this.frameCount = 0;

					// Load the image
					this.img = new Image();
					this.img.src = this.imagePath;
				}

				/**
				 * @param {HTMLCanvasElement} canvas
				 */
				setCanvas(canvas) {
					this.canvas = canvas;
				}

				/**
				 * @param {CanvasRenderingContext2D} context
				 */
				setContext(context) {
					this.context = context;
				}

				increaseFrameCount() {
					this.frameCount++;
				}

				/**
				 * Used for looping animations.
				 */
				resetFrameCount() {
					this.frameCount = 0;
				}

        /**
         * @param imageLayerPaths
         * @param animationScript
         * @param x
         * @param y
         * @return {*[]}
         */
				static bulkAnimate(imageLayerPaths, animationScript, x, y) {
					const animatedObjects = [];
					for (let i = 0; i < imageLayerPaths.length; i++) {
						animatedObjects.push(new AnimatedImage(imageLayerPaths[i], animationScript, x, y));
					}
					return animatedObjects;
				}
			}

			/**
			 * Used for animated effects like gun fire.
			 */
			class AnimatedEffect {

				/**
				 * @param {function} draw the script draws and animates the effect when called repeatedly
				 * @param {number} x starting horizontal position on the canvas
				 * @param {number} y starting vertical position on the canvas
				 */
				constructor(draw, x, y) {
					this.draw = draw;
					this.x = x;
					this.y = y;
					this.canvas = null;
					this.context = null;
					this.frameCount = 0;
				}

				/**
				 * @param {HTMLCanvasElement} canvas
				 */
				setCanvas(canvas) {
					this.canvas = canvas;
				}

				/**
				 * @param {CanvasRenderingContext2D} context
				 */
				setContext(context) {
					this.context = context;
				}


				increaseFrameCount() {
					this.frameCount++;
				}

				resetFrameCount() {
					this.frameCount = 0;
				}

			}

			class AnimationBackground {
				backgroudScript() {
					return function () {
						this.context.drawImage(this.img, this.x, this.y);
					}
				}

				make() {
					const backgroudImagePaths = [
						'structure-bg-default.png',
						'structure-bg-land.png',
						'structure-bg-lighten-15.png'
					];
					return AnimatedImage.bulkAnimate(backgroudImagePaths, this.backgroudScript(), 0, 0);
				}

			}

			class CarDrivingAnimation {
				drivingScript() {
					return function () {
						this.context.drawImage(this.img, this.x, this.y);

						this.x--;
						if (this.x < -64) {
							this.x = this.canvas.width;
						}
					}
				}

				make() {
					return [
						new AnimatedImage(
							'mobile-car-chassis.png',
							this.drivingScript(),
							64,
							0
						),
						new AnimatedImage(
							'mobile-car-land.png',
							this.drivingScript(),
							64,
							0
						)
					];
				}
			}

			class MechShootingAnimation {
				cannonFireScript() {
					return function() {
						this.context.drawImage(this.img, this.x, this.y);
						if (this.frameCount === 4) {
							this.x = 2;
						}
						if (this.frameCount === 8) {
							this.x = 1;
						}
						if (this.frameCount === 10) {
							this.x = 0;
						}
						if (this.frameCount === 30) {
							this.resetFrameCount();
						}
					};
				}

				mechKickBackScript() {
					return function() {
						this.context.drawImage(this.img, this.x, this.y);
						if (this.frameCount === 6) {
							this.x = 1;
						}
						if (this.frameCount === 10) {
							this.x = 0;
						}
						if (this.frameCount === 30) {
							this.resetFrameCount();
						}
					}
				}

				bulletScript() {
					return function() {
						this.context.fillStyle = '#ffff00';
						this.context.shadowColor = '#aaaa00';
						this.context.shadowBlur = 4;

						if (this.frameCount < 4) {
							this.context.fillRect(this.x, this.y, 11, 2);
						} else if (this.frameCount < 6) {
							this.context.fillRect(this.x, this.y, 5, 2);
						} else if (this.frameCount === 30) {
							this.resetFrameCount();
						}

						this.context.shadowBlur = 0;
					}
				}

				muzzleFlashScript() {
					return function() {
						this.context.strokeStyle = '#ffff00';
						this.context.shadowColor = '#aaaa00';
						this.context.shadowBlur = 4;

						if (this.frameCount < 4) {
							this.context.beginPath();
							this.context.ellipse(this.x, this.y, 3, 7, Math.PI, 0, 2 * Math.PI);
							this.context.stroke();
						} else if (this.frameCount < 6) {
							this.context.beginPath();
							this.context.ellipse(this.x, this.y, 1, 3, Math.PI, 0, 2 * Math.PI);
							this.context.stroke();
						} else if (this.frameCount === 30) {
							this.resetFrameCount();
						}

						this.context.shadowBlur = 0;
					}
				}

				shellCasingScript() {
					return function() {
						const trajectory = (x) => (Math.pow(x, 2) / 10) + this.y;
						const x = this.x + this.frameCount;
						const y = trajectory(this.frameCount);

						this.context.fillStyle = '#ffff00';
						this.context.fillRect(x, y, 2, 1);

						if (this.frameCount === 30) {
							this.resetFrameCount();
						}
					}
				}

				make() {
					const mechConfiguration = [
						'mobile-mech-body.png',
						'mobile-mech-power.png',
						'mobile-mech-sky.png',
						//'mobile-mech-defense.png',
					];
					const mechKickBack = AnimatedImage.bulkAnimate(mechConfiguration, this.mechKickBackScript(), 0, 0);
					return mechKickBack.concat([
						new AnimatedImage(
							'mobile-mech-attack.png',
							this.cannonFireScript(),
							0,
							0
						),
						new AnimatedEffect(
							this.muzzleFlashScript(),
							12,
							25
						),
						new AnimatedEffect(
							this.bulletScript(),
							1,
							24
						),
						new AnimatedEffect(
							this.shellCasingScript(),
							24,
							24
						)
					]);
				}
			}

			// const animationBackgroud = (new AnimationBackground()).make();
			// const animatedCar = (new CarDrivingAnimation()).make();
			// const animationEngine = new AnimationEngine('my-canvas');
			// animationEngine.registerAnimatedObjects(animationBackgroud);
			// animationEngine.registerAnimatedObjects(animatedCar);
			// animationEngine.play();

			const animationBackground = (new AnimationBackground()).make();
			const animatedMechShooting = (new MechShootingAnimation()).make();
			const animationEngine = new AnimationEngine('my-canvas', { flipHorizontally: true });
			animationEngine.registerAnimatedObjects(animationBackground);
			animationEngine.registerAnimatedObjects(animatedMechShooting);
			animationEngine.play();
		</script>
	</body>
</html>
